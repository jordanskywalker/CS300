# CS300

1. What was the problem you were solving in the projects for this course?
- In Project One, I was tasked with analyzing how different data structures perform in terms of efficiency, specifically looking at how they handle operations like insertion, deletion, and searching. The goal was to understand their strengths and weaknesses based on run-time and memory usage. Project Two was more hands-on, requiring me to implement a working program that organizes and prints a list of computer science courses in alphanumeric order. The challenge there was choosing the right data structure to make sorting and retrieval as efficient as possible.

2. How did you approach the problem? Consider why data structures are important to understand.
- My first step was to break down the problem and determine which data structures would be the best fit for each task. In Project One, I compared different structures and measured their performance to see which ones were most efficient in different scenarios. In Project Two, I decided to use a binary search tree because it allowed for quick insertion and in-order traversal, which naturally sorted the courses. 

3. How did you overcome any roadblocks you encountered while going through the activities or project?
- Like any coding project, I ran into my fair share of issues. In Project One, handling hash table collisions was more complicated than I initially expected, so I had to rethink my approach and refine my implementation. In Project Two, ensuring that the courses sorted correctly in both numerical and alphabetical order took some trial and error. I got past these obstacles by testing individual pieces of the code, using debugging tools, and researching best practices to find better solutions.

4. How has your work on this project expanded your approach to designing software and developing programs?
- These projects really reinforced how important it is to choose the right data structure for the problem at hand. Before this course, I didn’t always think about how much a data structure could impact performance, but now I approach problems with efficiency in mind. I’ve also gained a better appreciation for breaking down complex problems into smaller, more manageable parts, which has helped me write cleaner and more organized code.

5. How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
- I’ve gotten better at writing code that’s easier to understand and maintain. I make sure to use clear variable names, add meaningful comments, and structure my programs in a way that makes them easy to modify in the future. I also try to keep my functions focused and modular so that different parts of the program can be reused or updated without breaking everything else. Thinking about long-term readability and adaptability has made me more intentional about how I structure my code.
